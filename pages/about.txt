## 1. 시스템 개요

이 시스템은 수능 국어 지문을 출제하는 Multi-Agent입니다. LangGraph를 기반으로 에이전트 간 제어 흐름을 관리하고, FastAPI를 통해 에이전트의 출력을 실시간으로 스트리밍합니다.

### 왜 멀티 에이전트로 접근했는가?

수능 수준에 부합하는 독서 지문과 문항을 생성하는 것은 단일 LLM으로는 달성하기 어려운 복잡한 작업이었습니다.

-   글의 정보 밀도가 높고 출제를 염두한 섬세한 사전 설계가 필요
-   분야(인문/과학/사회 등)마다 다른 작문 스타일을 하나의 시스템 프롬프트로 구현하기 어려움
-   레퍼런스를 제공하기 위해서는 사용자가 일일이 프롬프트에 삽입해야 함

이러한 한계를 극복하기 위해 전문화된 에이전트들이 각자의 역할을 수행하며 협업하는 구조를 채택했습니다.

## 2. 에이전트 아키텍처

### 2.1 에이전트 구성 및 역할

시스템은 5개의 전문화된 에이전트로 구성되어 있으며, 각 에이전트는 특정 작업에 특화되어 있습니다:

| 에이전트         | 주요 역할                      | 사용 모델     |
| -------------- | ------------------------------ | ------------- |
| Supervisor     | 작업 흐름 조정 및 제어권 관리  | GPT-4.1       |
| Researcher     | 정보 수집 및 개념 지도 작성    | GPT-4.1     |
| Passage_editor | 개념 지도 기반 지문 작성       | Claude-3.7       |
| Question_editor| 지문 기반 문항 및 선지 생성    | Claude-3.7    |
| Validator      | 지문-문항 일관성 및 품질 검증 | GPT-4.1       |

### 2.2 에이전트 간 협업 구조

LangGraph 기반의 상태 그래프를 통해 에이전트 간 협업이 이루어집니다. 이 구조의 특징은:

-   **중앙 집중형 제어**: Supervisor가 사용자와 직접 소통하며, 각 에이전트에 작업 제어권을 전달합니다. 다른 에이전트의 작업 후에는 항상 Supervisor에게 작업 제어권이 반환됩니다.
    
-   **상태 기반 작업 관리**: LangGraph의 GraphState의 통합 메세지 히스토리를 통해 모든 에이전트가 작업 진행 상황을 공유합니다. 현재는 저장 공간으로 메모리를 사용합니다.(MemorySaver)
    
-   **조건부 전환**: 작업 결과에 따라 Supervisor Agent가 다음 단계로 진행할지 결정하고, 이에 따라가 작업 순서가 결정되는 동적 워크플로우
    

이러한 구조를 통해 복잡한 작업을 모듈화하고, 각 모듈이 유동적으로 작동하는 구조를 구현할 수 있었습니다.

## 3. 워크플로우: 지문 생성 프로세스

지문 생성은 다음과 같은 단계로 진행됩니다:

### 단계 1: 요청 분석 및 계획 수립

Supervisor 에이전트가 사용자 요청(주제, 난이도 등)을 분석하고 전체 작업 계획을 수립합니다. 이 단계에서는:

-   주제의 적합성 평가
-   작업 분배 계획 수립
-   전체 워크플로우 설계

### 단계 2: 리서치 및 개념 지도 작성

Supervisor의 지시에 따라 Researcher 에이전트가 활성화되어:

-   검색 도구를 활용해 주제 관련 자료 수집
-   핵심 개념과 개념 간 관계 분석
-   수능 지문에 적합한 수준의 개념 지도(7번에서 서술) 초안 작성
-   작업 완료 후 슈퍼바이저에게 제어권 반환

### 단계 3: 지문 작성

Supervisor가 Researcher의 결과물을 검토한 후 Passage_editor에게 제어권을 전달합니다. Passage_editor는:

-   개념 지도를 바탕으로 논리적 구조의 독서 지문 작성
-   수능 독서 지문 특유의 문체와 논리 전개 방식 적용
-   적절한 정보 밀도와 어휘 수준 조절
-   작업 완료 후 Supervisor에게 제어권 반환

### 단계 4: 문항 생성

Supervisor가 지문을 검토한 후 Question_editor에게 제어권을 전달합니다. Question_editor는:

-   지문에 대한 심층 분석 수행
-   다양한 유형(사실적 이해, 추론, 비판 등)의 문항 설계
-   정답 및 오답 선지 작성
-   문항 난이도 조절
-   작업 완료 후 Supervisor에게 제어권 반환

### 단계 5: 검증 및 최종화

Supervisor가 지문과 문항을 Validator에게 전달합니다. Validator는:

-   지문과 문항의 일관성 평가
-   논리적 오류나 부정확한 정보 검출
-   문항의 난이도와 변별력 평가
-   개선 사항 제안
-   작업 완료 후 Supervisor에게 제어권 반환

### 단계 6: 최종 결과 전달

Supervisor가 검증 결과를 검토하고 필요 시 수정을 지시한 후 최종 결과물을 사용자에게 전달합니다.

## 4. 작업 통제권 제어

### 4.1 작업 통제권 관리의 필요성

각 에이전트가 언제 활성화되고 비활성화될지를 Handoff 도구를 통해 명확히 관리하고 있습니다. 이로 인해 다음과 같은 장점이 있습니다.

-   에이전트 간 중복 작업 방지
-   선형 워크플로우를 유지하여 작업 순서를 동기적으로 관리
-   사용자가 작업 진행 상황을 명확하게 관찰 가능

### 4.2 Supervisor의 Handoff 도구 사용

LangGraph의 Command를 활용해 에이전트 간 제어 흐름을 관리했습니다. 제어권 전달은 다음과 같은 단계로 이루어집니다:

1.  현재 활성된 에이전트가 작업 완료 후, LangGraph의 엣지 구조에 따라 자연스럽게 Supervisor에게 작업 통제권을 반환
2.  작업 통제권을 이전해야 하는 경우, Supervisor는 Handoff 도구 사용
3.  해당 에이전트에게 통제권을 이전하는 Command 객체 생성
4.  StateGraph가 Command를 해석하여 대상 에이전트 활성화
5.  새 에이전트의 작업 시작

마치 릴레이 경주에서 바통을 전달하는 것과 유사합니다.

```python
@tool
async def handoff_for_agent(
    agent_name: Literal["validator", "passage_editor", "question_editor", "researcher"],
    state: Annotated[dict, InjectedState],
    tool_call_id: Annotated[str, InjectedToolCallId],
	):
    """다른 에이전트에게 제어권을 전달하는 도구"""
    message = ToolMessage(
        content="당신은 다른 에이전트로부터 통제권을 부여받았습니다. 현재까지의 작업 결과를 검토하고 다음 단계를 진행하세요.",
        tool_call_id=tool_call_id,
    )
    return Command(
        goto=agent_name,
        graph=Command.PARENT,
        update={"messages": state["messages"] + [message]}
    )

```

## 5. DB 검색 도구 부여

수능 지문 생성의 품질을 높이기 위해, 기출 지문을 벡터 DB에 임베딩하고, 에이전트가 활용할 수 있는 검색 도구 `retrieve_data`를 구현했습니다. 인간이 자료를 검색하고 분석하는 과정과 유사하게끔 설계했으며, 검색을 통해 명확한 기출 레퍼런스를 제공합니다. 이를 통해 에이전트의 작업 품질을 크게 향상시킬 수 있었습니다.

### 5.1 검색 시스템의 구조

-   ChromaDB 기반 벡터 데이터베이스에 지문 세트를 임베딩
-   `retrieve_date` 도구를 사용하여 동적으로 쿼리 생성
-   벡터 유사도 기반 쿼리를 통해 의미 기반 검색 가능
-   풍부한 메타데이터를 통한 필터링

### 5.2 DB 메타데이터 구조화

-   연도, 회차, 영역 등 기본 정보
-   분야 및 세부 분야 분류
-   문항 유형 및 난이도 정보
-   주요 키워드 및 개념 구조 분류

```python
@tool
async def retrieve_data(
    query: str,
    doc_type: Literal["passage", "question", "answer"] = None,
    year: Optional[int] = None,
    field: Optional[str] = None,
    question_type: Optional[str] = None,
    difficulty: Optional[str] = None,
    keyword_match: Optional[List[str]] = None,
    n_results: int = 3,
    state: Annotated[dict, InjectedState],
    tool_call_id: Annotated[str, InjectedToolCallId]
	):
    """기출 DB에서 다양한 필터와 메타데이터를 활용해 검색하는 도구"""
    # ChromaDB 클라이언트 초기화
    client = chromadb.PersistentClient(path="DB/kice", settings=Settings(anonymized_telemetry=False))
    collection = client.get_collection(
        name = 'kice_database',
        embedding_function=OpenAIEmbeddingFunction(
            model_name="text-embedding-3-large",
            api_key=os.environ.get("OPENAI_API_KEY")
        )
    )
    
    # 동적 필터링 조건 구성
    where_filter = {}
    if doc_type: where_filter["doc_type"] = doc_type
    if year: where_filter["year"] = year
    if field: where_filter["field"] = field
    if question_type: where_filter["question_types"] = {"$contains": question_type}
    if difficulty: where_filter["difficulty"] = difficulty
    if keyword_match: where_filter["keywords"] = {"$contains": keyword_match}
    
    # 벡터 검색 실행
    try:
        results = collection.query(
            query_texts=[query],
            n_results=n_results,
            where=where_filter if where_filter else None
        )
        
        # 결과 포맷팅
        formatted_results = []
        for i, (doc, metadata, id, distance) in enumerate(zip(
            results.get('documents', [[]])[0],
            results.get('metadatas', [[]])[0],
            results.get('ids', [[]])[0],
            results.get('distances', [[]])[0]
	        )):
            formatted_results.append({
                "rank": i+1,
                "document": doc,
                "metadata": metadata,
                "id": id,
                "relevance_score": 1 - distance  # 거리를 유사도 점수로 변환
            })
        
        return formatted_results
        
    except Exception as e:
        logger.error(f"검색 오류: {e}", exc_info=True)
        return f"검색 중 오류 발생: {e}"

```

### 5.3 검색 프로세스

LLM 에이전트는 다음과 같은 방식으로 검색 시스템을 활용합니다:

1.  태스크 분석: 현재 작업에 필요한 정보 유형 파악
2.  쿼리 구성: 효과적인 검색을 위한 쿼리 및 필터 설계, 검색 도구 호출
3.  검색 실행: 검색 도구가 벡터 데이터베이스에 쿼리 전송, 자연어로 다시 임베딩
4.  결과 분석: 검색 결과의 관련성과 유용성 평가
5.  정보 통합: 유용한 정보를 현재 작업에 통합

## 6. 서버-클라이언트 구조 및 스트리밍 방식

### 6.1 서버-클라이언트 아키텍처

시스템은 백엔드 서버와 프론트엔드 클라이언트로 구성된 분리된 아키텍처를 채택했습니다:

-   **백엔드 서버 (FastAPI)**
    
    -   `StateGraph` 인스턴스 생성, 메모리 초기화
    -   ChromaDB 클라이언트 초기화
    -   LLM API 호출 처리
    -   비동기 요청 처리
    -   스트리밍 응답 생성, `/stream` 엔드포인트를 받아 전송


-   **프론트엔드 클라이언트 (Streamlit)**
    
    -   사용자 인터페이스 제공
    -   백엔드 서버와 통신
    -   스트리밍 데이터 처리
    -   생성된 지문과 문항은 전용 아티팩트에 따로 표시
    -   세션 상태 관리(추후 백앤드 측 DB화 고려)


### 6.2 실시간 스트리밍 메커니즘

LLM 생성은 시간이 소요되는 작업이기 때문에, 사용자 경험 향상을 위해 SSE(Server-Sent Events) 기반 실시간 스트리밍 방식을 구현했습니다:

-   **서버 측 구현**
    
    -   LangGraph의 `astream` 메서드를 활용한 비동기 스트리밍
    -   에이전트별 출력 구분 및 메타데이터 포함
    -   구조화된 JSON 형식으로 이벤트 전송
    -   오류 처리
-   **클라이언트 측 구현**
    
    -   EventSource 객체를 통한 스트림 연결
    -   메시지 유형별 처리(일반 메시지, 도구 호출, 오류 등)
    -   에이전트별 출력을 분리하여 표시
    -   스트리밍 중단 및 오류 발생 시 정확한 로깅 처리

스트리밍 방식은 `astream` 메서드와 `stream_mode=messages`를 사용하여,토큰 단위로 스트리밍 및 파싱합니다.

```python
@app.post("/chat/stream")
async def chat_stream_endpoint(request: ChatRequest):
    async def event_generator():
        async for item in stream_agent_response(request):
            # item은 이미 JSON 문자열
            #logger.info(f"전송된 청크:\n{item}")
            yield item + "\n"  # iter_lines()가 줄 단위로 인식하도록
    return StreamingResponse(
        event_generator(),
        media_type="application/json",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        }
    )

```

## 7. 개념 지도 (Concept Map)

### 7.1 개념 지도의 문제의식과 목적

프로젝트의 핵심 과제는 LLM이 생성하는 콘텐츠의 논리적 밀도와 난이도를 효과적으로 통제하는 것이었습니다. 단순히 "더 어렵게 작성해 주세요" 또는 "논리적 밀도를 높여주세요"라는 프롬프트만으로는 원하는 수준의 출제 품질을 달성할 수 없었습니다.

이 문제를 해결하기 위해, 지문의 논리적 구조를 명시적으로 표현하고 정량화할 수 있는 '개념 지도' 스키마를 개발했습니다. 개념 지도는 지문에 포함된 개념들(노드)과 그 개념 간의 논리적 관계(엣지)를 그래프 형태로 표현합니다.

### 7.2 개념 지도의 구조

개념 지도는 두 가지 핵심 요소로 구성됩니다:

1.  **노드(Nodes)**: 지문에 등장하는 핵심 개념, 이론, 현상, 개체 등을 표현
    
    -   각 노드는 고유 ID, 레이블, 설명 등의 속성을 가짐
    -   예: "의무론", "결과론", "자율주행 알고리즘", "면역 체계" 등
2.  **엣지(Edges)**: 노드 간의 논리적 관계를 표현
    
    -   15가지 관계 유형과 27가지 세부 레이블로 체계화

##### 엣지 유형 (일부)

| 타입         | 핵심 논리                      | 레이블                             |
| ------------ | ------------------------------ | -------------------------------- |
| **계층/분류** | A가 B의 범주에 속함             | `belongs_to`                     |
| **정의/설명** | A가 B로 정의됨                 | `defines`                        |
| **구성/요소** | A가 B를 구성요소로 포함         | `has_part`                       |
| **속성/특성** | A가 B라는 속성을 가짐           | `has_attribute`                  |
| **비교/대조** | A와 B가 유사하거나 다름        | `is_similar_to`, `differs_from` |
| **인과 관계** | A가 B의 원인이거나 영향을 줌 | `causes`, `influences`            |

이러한 구조화된 표현을 통해, 텍스트의 논리적 복잡성을 정량적으로 설계하고 지시를 내릴 수 있게 됩니다.

### 7.3 개념 지도를 활용한 정량적 프롬프트 및 결과물 분석

개념 지도는 지문의 논리적 특성을 다양한 측면에서 정량화할 수 있는 기반을 제공합니다. 현재 다음과 같은 측정 및 분석 방법을 연구 중입니다:

-   **정보 밀도 측정**: 노드 수와 엣지 수를 활용한 공식을 설계해 정보량을 나타내는 지표 개발
-   **논리 복잡성 분석**: 엣지 유형별 비율과 노드 당 엣지 수 등을 활용하여 정보 밀도를 나타내는 지표 개발
-   **난이도 예측 모델**: 특정 엣지 유형 및 패턴과 문항 난이도 간의 상관관계 분석을 통해 난이도를 나타내는 지표 개발
-   **패턴 인식**: 수능 고난도 문항에서 자주 출현하는 논리 구조 패턴 식별

위와 같은 지표들을 프롬프트 입력 시 활용함으로서, LLM에게 명시적인 논리 구조를 주문할 수 있습니다.

> 프롬프트 예시: "노드 수가 최소 30, 엣지 수가 40, 엣지 유형은 4번 타입이 50% 이상 주를 이루도록 개념 지도를 설계해 줘."

이러한 정량적 접근법은 지문의 논리적 특성을 객관적으로 측정하고, 원하는 수준의 난이도와 밀도를 갖춘 지문을 일관되게 생성하는 데 기여할 것으로 기대하고 있습니다.

## 8. 시스템 효과성 및 개발 성과

### 8.1 성과 측정

-   **제작 시간 혁신**: 기존 수능 지문 제작 기간(약 2개월)을 약 5분으로 단축
-   **비용 효율성**: 기존 제작 비용(세트당 약 200만원)을 API 비용(약 500원) 수준으로 절감
-   **생성 품질**: 단일 LLM 대비 지문의 논리적 일관성 및 복잡성 크게 향상

### 8.2 교육적 가치

-   **맞춤형 학습 자료**: 개인별 학습 수준과 필요에 따른 콘텐츠 생성 가능
-   **콘텐츠 다양화**: 교재 제작의 시간적, 비용적 제약 해소로 더 다양한 주제와 난이도 제공 가능
-   **고품질 콘텐츠 접근성**: 비용 장벽 감소로 더 많은 학생에게 양질의 학습 자료 제공

### 8.3 시장 잠재력

-   **교육 기관 도입**: 강남대성학원 등 주요 교육기관과 도입 관련 논의 진행 중, 교육 스타트업과 협업 논의 중
-   **에듀테크 통합**: 기존 학습 관리 시스템과의 통합, 기능 확장(예: 기출 해설)을 통한 학습 생태계 구축 가능성

## 부록 1: 코드 예제

### 에이전트 그래프 구성

```python
# 에이전트 그래프 구현 (graph_factory.py)
def create_compiled_graph(memory):
    # 에이전트 정의
    supervisor_agent = create_react_agent(
        model=Model_gpt4_1,
        tools=[handoff_for_agent, prompt_for_subject_selection],
        prompt=supervisor_prompt
    )
    
    researcher_agent = create_react_agent(
        model=Model_claude_3_7,
        tools=[retrieve_data, prompt_for_humanities_writing],
        prompt=researcher_prompt
    )
    
    # 다른 에이전트들 정의...
    
    # 상태 그래프 구성
    builder = StateGraph(MultiAgentState)
    
    # 노드 추가
    builder.add_node("supervisor", supervisor_agent)
    builder.add_node("researcher", researcher_agent)
    builder.add_node("passage_editor", passage_editor_agent)
    builder.add_node("question_editor", question_editor_agent)
    builder.add_node("validator", validator_agent)
    
    # 기본 엣지 정의 - supervisor에서 다른 에이전트 간 전환은 Command를 통해 이루어집니다.
    builder.add_edge(START, "supervisor")
    builder.add_edge("researcher", "supervisor")
    builder.add_edge("passage_editor", "supervisor")
    builder.add_edge("question_editor", "supervisor")
    builder.add_edge("validator", "supervisor")
    
    # 그래프 컴파일
    return builder.compile(checkpointer=memory)

```

## 부록2 : 개념 지도 구축 문서

### 1. 소개 및 목표 (Introduction & Goal)

본 문서는 **수능/모의평가 국어 독서 지문**의 내용을 분석하여, 지문의 논리 구조와 핵심 정보를 명확하게 표현하는 **개념 지도 (지식 그래프)**를 구축하기 위한 가이드라인을 제공합니다.

**주요 목표:**

*   지문 내 핵심 개념, 개체, 사건 및 그들 간의 관계를 구조적으로 표현합니다.
*   지문의 논리적 흐름(인과, 비교, 조건, 논증 등)을 명확히 포착합니다.
*   구축된 그래프를 통해 제시된 **선지의 정오답을 판별**하는 데 필요한 근거를 효과적으로 추론하고 검증할 수 있도록 지원합니다.

### 2. 범위 (Scope)

*   **대상 텍스트:** 대한민국 대학수학능력시험 (수능) 및 모의평가 국어 영역의 **독서 지문** (비문학).
*   **활용:** LLM 등을 활용한 지문 분석, 논리 관계 추출, 선지 정오답 판별 지원 시스템의 기반 데이터 구축.

### 3. 핵심 구성 요소 (Core Components)

개념 지도는 다음 두 가지 핵심 요소로 구성됩니다.

1.  **노드 (Nodes):** 지문에 등장하는 핵심 개념, 개체, 사건, 속성 값 등을 나타냅니다.
2.  **엣지 (Edges):** 노드 간의 관계를 나타냅니다. 엣지는 특정 타입(Type)과 레이블(Label)을 가집니다.


### 4. 노드 식별 및 표현 (Node Identification and Representation)

*   **식별 대상:** 지문 내에서 중요한 의미를 가지는 **명사, 명사구, 핵심 동사/형용사구(개념화된 것), 고유 명사, 특정 수치/날짜/기간, 이론/법칙/원리 이름** 등을 식별합니다.
*   **정규화 (Normalization):** 일관성을 위해 노드 레이블을 정규화합니다.
    *   가능하면 단수형 사용.
    *   동의어/유의어는 대표 용어 통일.
    *   약어는 완전한 명칭 사용 또는 병기.
*   **표현:** 노드는 JSON 구조 내에서 명확하고 간결한 `label` (텍스트 레이블)로 표현됩니다.

### 5. 엣지 스키마 (Edge Schema - v4.1)

엣지는 노드 간의 관계를 표현하며, 아래 정의된 **최종 엣지 스키마(v4.1)**를 엄격히 준수해야 합니다. 이 스키마는 선지 판별 논리에 필수적인 관계들을 중심으로 단순화되었습니다.

#### 5.1. 스키마 개요

*   **총 타입 수:** 15개
*   **총 레이블 수:** 27개 (모두 필수 레이블)

#### 5.2. 상세 정의

#### 2.1. `Classification` (분류)
*   **설명:** 개체 간의 범주화, 유형화, 그룹 소속 관계를 나타냅니다.
*   **레이블:**
    *   `belongs_to`: A가 B의 한 종류이거나 B라는 범주/그룹에 속함을 나타냄.

#### 2.2. `Definition` (정의)
*   **설명:** 용어, 개념, 사건 등의 의미를 정의하거나 설명/묘사하는 관계를 나타냅니다.
*   **레이블:**
    *   `defines`: A가 B의 의미를 정의하거나 설명/묘사함.

#### 2.3. `Composition` (구성)
*   **설명:** 전체와 부분, 물리적 또는 개념적 구성 요소 관계를 나타냅니다.
*   **레이블:**
    *   `has_part`: A가 B를 구성 요소 또는 부분으로 가짐.

#### 2.4. `Property` (속성)
*   **설명:** 개체의 특징, 상태, 속성 또는 구체적인 값을 나타냅니다.
*   **레이블:**
    *   `has_attribute`: A가 B라는 속성, 특징, 상태 또는 값을 가짐.

#### 2.5. `Comparison` (비교)
*   **설명:** 둘 이상의 개체 간의 (주로 질적인) 유사점 또는 차이점을 비교/대조합니다.
*   **레이블:**
    *   `is_similar_to`: A가 B와 질적으로 유사함.
    *   `differs_from`: A가 B와 질적으로 차이가 나거나 대조됨.

#### 2.6. `Causality` (인과)
*   **설명:** 사건, 상태, 현상 간의 원인과 결과, 영향 관계를 나타냅니다.
*   **레이블:**
    *   `causes`: A가 B의 직접적인 원인이 됨.
    *   `influences`: A가 B에 간접적 영향을 미치거나 기여함.

#### 2.7. `Conditionality` (조건)
*   **설명:** 어떤 사건이나 상태가 발생하기 위한 필요 조건 또는 의존 관계를 나타냅니다.
*   **레이블:**
    *   `requires`: A가 발생하거나 성립하기 위해 B가 필요함.
    *   `depends_on`: A가 B의 값이나 상태에 따라 달라짐.

#### 2.8. `Temporal` (시간)
*   **설명:** 사건이나 개체의 시간적 위치, 순서, 기간 관계를 나타냅니다.
*   **레이블:**
    *   `occurs_at`: A가 특정 시점 또는 기간 B에 발생함.
    *   `before`: A가 B보다 시간적으로 먼저 발생함.
    *   `after`: A가 B보다 시간적으로 나중에 발생함.

#### 2.9. `Spatial` (공간)
*   **설명:** 개체의 위치, 장소 관계를 나타냅니다.
*   **레이블:**
    *   `is_located_at`: A가 B라는 장소에 위치함.

#### 2.10. `Purpose` (목적/수단/기능)
*   **설명:** 행위의 목적, 목적 달성을 위한 수단, 또는 개체의 기능/역할 관계를 나타냅니다.
*   **레이블:**
    *   `has_purpose`: A 행위나 개체의 목적이 B임.
    *   `uses_means`: A가 목적 달성을 위해 B를 수단으로 사용함.
    *   `functions_as`: A가 B로서의 기능이나 역할을 수행함.

#### 2.11. `Example` (예시)
*   **설명:** 일반적인 개념이나 주장에 대한 구체적인 예시/사례 관계를 나타냅니다.
*   **레이블:**
    *   `is_example_of`: A가 일반적인 개념/주장 B의 구체적인 사례임.

#### 2.12. `Reference` (참조)
*   **설명:** 정보의 출처, 인용, 참조 관계를 나타냅니다.
*   **레이블:**
    *   `refers_to`: A가 B를 참조하거나 언급함.
    *   `is_source_of`: A가 B 정보의 출처임.

#### 2.13. `Evaluation` (평가/입장)
*   **설명:** 특정 대상에 대한 화자나 주체의 평가, 간주, 태도, 입장 관계를 나타냅니다.
*   **레이블:**
    *   `views_as`: A가 B를 C라고 평가하거나 간주함.
    *   `has_stance`: A가 특정 주제 B에 대해 C라는 입장을 가짐.

#### 2.14. `Argumentation` (논증)
*   **설명:** 주장, 결론, 행동에 대한 근거, 이유 제시 또는 반박/모순 관계를 나타냅니다.
*   **레이블:**
    *   `supports`: A가 주장/결론/행동 B를 지지하거나 정당화하는 근거가 됨.
    *   `contradicts`: A가 B와 모순되거나 B를 반박함.

#### 2.15. `QuantComparison` (양적 비교)
*   **설명:** 둘 이상의 개체 간 크기, 수량, 정도 등 양적인 비교 관계를 나타냅니다.
*   **레이블:**
    *   `is_greater_than`: A가 B보다 양적으로 큼 (>).
    *   `is_less_than`: A가 B보다 양적으로 작음 (<).
    *   `is_equal_to`: A가 B와 양적으로 같음 (=).


#### 5.3. 스키마 요약표

| 타입 (Type)         | 레이블 (Labels)                                    |
| :------------------ | :------------------------------------------------- |
| `Classification`    | `belongs_to`                                       |
| `Definition`        | `defines`                                          |
| `Composition`       | `has_part`                                         |
| `Property`          | `has_attribute`                                    |
| `Comparison`        | `is_similar_to`, `differs_from`                    |
| `Causality`         | `causes`, `influences`                             |
| `Conditionality`    | `requires`, `depends_on`                           |
| `Temporal`          | `occurs_at`, `before`, `after`                     |
| `Spatial`           | `is_located_at`                                    |
| `Purpose`           | `has_purpose`, `uses_means`, `functions_as`        |
| `Example`           | `is_example_of`                                    |
| `Reference`         | `refers_to`, `is_source_of`                        |
| `Evaluation`        | `views_as`, `has_stance`                           |
| `Argumentation`     | `supports`, `contradicts`                          |
| `QuantComparison`   | `is_greater_than`, `is_less_than`, `is_equal_to` |



### 6. 그래프 구축 방향성 (Graph Building Workflow)

1.  **지문 이해 (Text Comprehension):** 대상 지문을 주의 깊게 읽고 전체 구조, 문단별 핵심 내용, 주요 논증 및 논리적 흐름을 파악합니다.
2.  **노드 추출 (Node Extraction):** 지문에서 핵심 개념, 개체, 사건 등을 식별하고 정규화하여 노드 목록을 만듭니다. (4번 가이드라인 참고)
3.  **엣지 추출 (Edge Extraction):** 노드들 사이의 관계를 파악합니다. 지문에 명시적으로 드러나거나 논리적으로 강하게 함축된 관계에 집중합니다.
4.  **스키마 적용 (Schema Application):** 파악된 각 관계에 대해 **엣지 스키마(v4.1)**에서 가장 적합한 **타입(Type)**과 **레이블(Label)**을 선택하여 엣지를 생성합니다.
5.  **핵심 관계 집중 (Focus on Key Relations):** 특히 선지 구성에 자주 활용되는 관계 (예: `Causality`, `Comparison`, `Conditionality`, `Argumentation`, `Definition`, `Property`, `QuantComparison`)를 누락하지 않도록 주의합니다.
6.  **반복 및 검토 (Iteration & Review):** 전체 지문에 대해 과정을 반복하고, 생성된 노드와 엣지가 지문의 내용을 정확하고 일관되게 반영하는지 검토합니다.


### 7. 표현 형식 (Representation Format)

구축된 개념 지도는 상세 메타데이터를 포함하는 **JSON 형식**으로 표현됩니다. 최상위 JSON 객체는 그래프 식별 정보, 원본 문서 정보, 그리고 `nodes`와 `edges` 리스트를 포함합니다.

*   **최상위 객체 구조:**
    *   `graph_id` (String): 그래프 고유 ID. **필수.**
    *   `document_source` (Object): 원본 문서 정보. **필수.**
        *   `title` (String): 문서 제목.
        *   `source_file` (String): 원본 파일명.
        *   `sections` (Array of Strings): 관련 섹션 범위.
    *   `nodes` (Array): 노드 객체 리스트. **필수.**
    *   `edges` (Array): 엣지 객체 리스트. **필수.**

*   **`nodes` 리스트:**
    *   각 노드 객체 속성:
        *   `id` (String): 노드 고유 ID. **필수.**
        *   `label` (String): 노드 텍스트 이름 (정규화). **필수.**
        *   `description` (String, Optional): 노드 설명.
        *   `text_span` (Array, Optional): 원본 텍스트 내 위치 [시작, 끝].
        *   `type` (String, Optional): 노드 의미론적 유형.

*   **`edges` 리스트:**
    *   각 엣지 객체 속성:
        *   `source_id` (String): 시작 노드 ID. **필수.**
        *   `target_id` (String): 끝 노드 ID. **필수.**
        *   `type` (String): 엣지 스키마(v4.1) 타입 이름. **필수.**
        *   `label` (String): 엣지 스키마(v4.1) 레이블. **필수.**
        *   `metadata` (Object): 엣지 추가 정보.
            *   `supporting_sentence` (String): 근거가 되는 원본 문장. **필수.**
            *   `text_span` (Array, Optional): 관계 근거 텍스트 위치 [시작, 끝].
            *   `(기타)`: 필요시 추가 메타데이터 포함 가능.


### 8. 품질 기준 (Quality Criteria)

*   **정확성 (Accuracy):** 그래프는 지문에 명시/함축된 내용만을 반영해야 함.
*   **완전성 (Completeness):** 선지 판별에 중요한 핵심 관계는 가급적 포함해야 함.
*   **일관성 (Consistency):** 노드 표현과 스키마 적용이 일관되어야 함.
*   **스키마 준수 (Schema Compliance):** 모든 엣지는 정의된 스키마(v4.1)를 사용해야 함.
*   **JSON 형식 준수 (JSON Format Compliance):** 최종 결과물은 정의된 JSON 형식을 따라야 함.
*   **근거 명시 (Evidence Citation):** 모든 엣지는 `metadata.supporting_sentence`를 통해 근거 문장을 명시해야 함.

